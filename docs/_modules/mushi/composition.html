

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>mushi.composition &mdash; mushi  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/style.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html">
          

          
            
            <img src="../../_static/logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/quickstart.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cite.html">Citing <code class="docutils literal notranslate"><span class="pre">mushi</span></code></a></li>
</ul>
<p class="caption"><span class="caption-text">Notebooks</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/simulation.html">Testing with simulations</a></li>
</ul>
<p class="caption"><span class="caption-text">API Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../mushi.html">Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mushi.html#submodules">Submodules</a></li>
</ul>
<p class="caption"><span class="caption-text">Developer Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../developer.html">Open source code repository</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer.html#update-documentation">Update documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer.html#test-notebook">Test notebook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer.html#todo-list">Todo list</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">mushi</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>mushi.composition</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for mushi.composition</h1><div class="highlight"><pre>
<span></span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Functions for compositional data analysis.</span>

<span class="sd">It was copied from the :mod:`skbio.stats.composition` module and edited slightly to</span>
<span class="sd">enable compatibility with the JAX package.</span>

<span class="sd">Many &#39;omics datasets are inherently compositional - meaning that they</span>
<span class="sd">are best interpreted as proportions or percentages rather than</span>
<span class="sd">absolute counts.</span>

<span class="sd">Formally, :math:`x` is a composition if :math:`\sum_{i=0}^D x_{i} = c`</span>
<span class="sd">and :math:`x_{i} &gt; 0`, :math:`1 \leq i \leq D` and :math:`c` is a real</span>
<span class="sd">valued constant and there are :math:`D` components for each</span>
<span class="sd">composition. In this module :math:`c=1`. Compositional data can be</span>
<span class="sd">analyzed using Aitchison geometry. [1]_</span>

<span class="sd">However, in this framework, standard real Euclidean operations such as</span>
<span class="sd">addition and multiplication no longer apply. Only operations such as</span>
<span class="sd">perturbation and power can be used to manipulate this data.</span>

<span class="sd">This module allows two styles of manipulation of compositional data.</span>
<span class="sd">Compositional data can be analyzed using perturbation and power</span>
<span class="sd">operations, which can be useful for simulation studies. The</span>
<span class="sd">alternative strategy is to transform compositional data into the real</span>
<span class="sd">space.  Right now, the centre log ratio transform (clr) and</span>
<span class="sd">the isometric log ratio transform (ilr) [2]_ can be used to accomplish</span>
<span class="sd">this. This transform can be useful for performing standard statistical</span>
<span class="sd">tools such as parametric hypothesis testing, regressions and more.</span>

<span class="sd">The major caveat of using this framework is dealing with zeros.  In</span>
<span class="sd">the Aitchison geometry, only compositions with nonzero components can</span>
<span class="sd">be considered. The multiplicative replacement technique [3]_ can be</span>
<span class="sd">used to substitute these zeros with small pseudocounts without</span>
<span class="sd">introducing major distortions to the data.</span>

<span class="sd">References</span>
<span class="sd">----------</span>
<span class="sd">.. [1] V. Pawlowsky-Glahn, &quot;Lecture Notes on Compositional Data Analysis&quot;</span>
<span class="sd">   (2007)</span>

<span class="sd">.. [2] J. J. Egozcue.,  &quot;Isometric Logratio Transformations for</span>
<span class="sd">   Compositional Data Analysis&quot; Mathematical Geology, 35.3 (2003)</span>

<span class="sd">.. [3] J. A. Martin-Fernandez,  &quot;Dealing With Zeros and Missing Values in</span>
<span class="sd">   Compositional Data Sets Using Nonparametric Imputation&quot;,</span>
<span class="sd">   Mathematical Geology, 35.3 (2003)</span>


<span class="sd">Examples</span>
<span class="sd">--------</span>

<span class="sd">&gt;&gt;&gt; import numpy as np</span>
<span class="sd">&gt;&gt;&gt; import mushi.composition as cmp</span>

<span class="sd">Consider a very simple environment with only 3 species. The species</span>
<span class="sd">in the environment are equally distributed and their proportions are</span>
<span class="sd">equivalent:</span>

<span class="sd">&gt;&gt;&gt; otus = np.array([1./3, 1./3., 1./3])</span>

<span class="sd">Suppose that an antibiotic kills off half of the population for the</span>
<span class="sd">first two species, but doesn&#39;t harm the third species. Then the</span>
<span class="sd">perturbation vector would be as follows</span>

<span class="sd">&gt;&gt;&gt; antibiotic = np.array([1./2, 1./2, 1])</span>

<span class="sd">And the resulting perturbation would be</span>

<span class="sd">&gt;&gt;&gt; cmp.perturb(otus, antibiotic)</span>
<span class="sd">DeviceArray([0.25, 0.25, 0.5 ], dtype=float64)</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># ----------------------------------------------------------------------------</span>
<span class="c1"># Copyright (c) 2013--, scikit-bio development team.</span>
<span class="c1">#</span>
<span class="c1"># Distributed under the terms of the Modified BSD License.</span>
<span class="c1">#</span>
<span class="c1"># The full license is in the file COPYING.txt, distributed with this software.</span>
<span class="c1"># ----------------------------------------------------------------------------</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">jax.numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">onp</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span>


<div class="viewcode-block" id="closure"><a class="viewcode-back" href="../../stubs/mushi.composition.closure.html#mushi.composition.closure">[docs]</a><span class="k">def</span> <span class="nf">closure</span><span class="p">(</span><span class="n">mat</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs closure to ensure that all elements add up to 1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mat : array_like</span>
<span class="sd">       a matrix of proportions where</span>
<span class="sd">       rows = compositions</span>
<span class="sd">       columns = components</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array_like, np.float64</span>
<span class="sd">       A matrix of proportions where all of the values</span>
<span class="sd">       are nonzero and each composition (row) adds up to 1</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">       Raises an error if any values are negative.</span>
<span class="sd">    ValueError</span>
<span class="sd">       Raises an error if the matrix has more than 2 dimension.</span>
<span class="sd">    ValueError</span>
<span class="sd">       Raises an error if there is a row that has all zeros.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import mushi.composition as cmp</span>
<span class="sd">    &gt;&gt;&gt; X = np.array([[2, 2, 6], [4, 4, 2]])</span>
<span class="sd">    &gt;&gt;&gt; cmp.closure(X)</span>
<span class="sd">    DeviceArray([[0.2, 0.2, 0.6],</span>
<span class="sd">                 [0.4, 0.4, 0.2]], dtype=float64)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
    <span class="c1"># if np.any(mat &lt; 0):</span>
    <span class="c1">#     raise ValueError(&quot;Cannot have negative proportions&quot;)</span>
    <span class="c1"># if mat.ndim &gt; 2:</span>
    <span class="c1">#     raise ValueError(&quot;Input matrix can only have two dimensions or less&quot;)</span>
    <span class="c1"># if np.all(mat == 0, axis=1).sum() &gt; 0:</span>
    <span class="c1">#     raise ValueError(&quot;Input matrix cannot have rows with all zeros&quot;)</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="n">mat</span> <span class="o">/</span> <span class="n">mat</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mat</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span></div>


<div class="viewcode-block" id="multiplicative_replacement"><a class="viewcode-back" href="../../stubs/mushi.composition.multiplicative_replacement.html#mushi.composition.multiplicative_replacement">[docs]</a><span class="k">def</span> <span class="nf">multiplicative_replacement</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Replace all zeros with small non-zero values</span>

<span class="sd">    It uses the multiplicative replacement strategy [1]_ ,</span>
<span class="sd">    replacing zeros with a small positive :math:`\delta`</span>
<span class="sd">    and ensuring that the compositions still add up to 1.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mat: array_like</span>
<span class="sd">       a matrix of proportions where</span>
<span class="sd">       rows = compositions and</span>
<span class="sd">       columns = components</span>
<span class="sd">    delta: float, optional</span>
<span class="sd">       a small number to be used to replace zeros</span>
<span class="sd">       If delta is not specified, then the default delta is</span>
<span class="sd">       :math:`\delta = \frac{1}{N^2}` where :math:`N`</span>
<span class="sd">       is the number of components</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray, np.float64</span>
<span class="sd">       A matrix of proportions where all of the values</span>
<span class="sd">       are nonzero and each composition (row) adds up to 1</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">       Raises an error if negative proportions are created due to a large</span>
<span class="sd">       `delta`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This method will result in negative proportions if a large delta is chosen.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] J. A. Martin-Fernandez. &quot;Dealing With Zeros and Missing Values in</span>
<span class="sd">           Compositional Data Sets Using Nonparametric Imputation&quot;</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import mushi.composition as cmp</span>
<span class="sd">    &gt;&gt;&gt; X = np.array([[.2,.4,.4, 0],[0,.5,.5,0]])</span>
<span class="sd">    &gt;&gt;&gt; cmp.multiplicative_replacement(X)</span>
<span class="sd">    DeviceArray([[0.1875, 0.375 , 0.375 , 0.0625],</span>
<span class="sd">                 [0.0625, 0.4375, 0.4375, 0.0625]], dtype=float64)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="n">closure</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
    <span class="n">z_mat</span> <span class="o">=</span> <span class="p">(</span><span class="n">mat</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">num_feats</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">tot</span> <span class="o">=</span> <span class="n">z_mat</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">delta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">num_feats</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

    <span class="n">zcnts</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">tot</span> <span class="o">*</span> <span class="n">delta</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">zcnts</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The multiplicative replacment created negative &#39;</span>
                         <span class="s1">&#39;proportions. Consider using a smaller `delta`.&#39;</span><span class="p">)</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">z_mat</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">zcnts</span> <span class="o">*</span> <span class="n">mat</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mat</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span></div>


<div class="viewcode-block" id="perturb"><a class="viewcode-back" href="../../stubs/mushi.composition.perturb.html#mushi.composition.perturb">[docs]</a><span class="k">def</span> <span class="nf">perturb</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs the perturbation operation.</span>

<span class="sd">    This operation is defined as</span>

<span class="sd">    .. math::</span>
<span class="sd">        x \oplus y = C[x_1 y_1, \ldots, x_D y_D]</span>

<span class="sd">    :math:`C[x]` is the closure operation defined as</span>

<span class="sd">    .. math::</span>
<span class="sd">        C[x] = \left[\frac{x_1}{\sum_{i=1}^{D} x_i},\ldots,</span>
<span class="sd">                     \frac{x_D}{\sum_{i=1}^{D} x_i} \right]</span>

<span class="sd">    for some :math:`D` dimensional real vector :math:`x` and</span>
<span class="sd">    :math:`D` is the number of components for every composition.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like, float</span>
<span class="sd">        a matrix of proportions where</span>
<span class="sd">        rows = compositions and</span>
<span class="sd">        columns = components</span>
<span class="sd">    y : array_like, float</span>
<span class="sd">        a matrix of proportions where</span>
<span class="sd">        rows = compositions and</span>
<span class="sd">        columns = components</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray, np.float64</span>
<span class="sd">       A matrix of proportions where all of the values</span>
<span class="sd">       are nonzero and each composition (row) adds up to 1</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import mushi.composition as cmp</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([.1,.3,.4, .2])</span>
<span class="sd">    &gt;&gt;&gt; y = np.array([1./6,1./6,1./3,1./3])</span>
<span class="sd">    &gt;&gt;&gt; cmp.perturb(x,y)</span>
<span class="sd">    DeviceArray([0.0625, 0.1875, 0.5   , 0.25  ], dtype=float64)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">closure</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">closure</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">closure</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span></div>


<div class="viewcode-block" id="perturb_inv"><a class="viewcode-back" href="../../stubs/mushi.composition.perturb_inv.html#mushi.composition.perturb_inv">[docs]</a><span class="k">def</span> <span class="nf">perturb_inv</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs the inverse perturbation operation.</span>

<span class="sd">    This operation is defined as</span>

<span class="sd">    .. math::</span>
<span class="sd">        x \ominus y = C[x_1 y_1^{-1}, \ldots, x_D y_D^{-1}]</span>

<span class="sd">    :math:`C[x]` is the closure operation defined as</span>

<span class="sd">    .. math::</span>
<span class="sd">        C[x] = \left[\frac{x_1}{\sum_{i=1}^{D} x_i},\ldots,</span>
<span class="sd">                     \frac{x_D}{\sum_{i=1}^{D} x_i} \right]</span>


<span class="sd">    for some :math:`D` dimensional real vector :math:`x` and</span>
<span class="sd">    :math:`D` is the number of components for every composition.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        a matrix of proportions where</span>
<span class="sd">        rows = compositions and</span>
<span class="sd">        columns = components</span>
<span class="sd">    y : array_like</span>
<span class="sd">        a matrix of proportions where</span>
<span class="sd">        rows = compositions and</span>
<span class="sd">        columns = components</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray, np.float64</span>
<span class="sd">       A matrix of proportions where all of the values</span>
<span class="sd">       are nonzero and each composition (row) adds up to 1</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import mushi.composition as cmp</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([.1,.3,.4, .2])</span>
<span class="sd">    &gt;&gt;&gt; y = np.array([1./6,1./6,1./3,1./3])</span>
<span class="sd">    &gt;&gt;&gt; cmp.perturb_inv(x,y)</span>
<span class="sd">    DeviceArray([0.14285714, 0.42857143, 0.28571429, 0.14285714], dtype=float64)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">closure</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">closure</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">closure</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">y</span><span class="p">)</span></div>


<div class="viewcode-block" id="power"><a class="viewcode-back" href="../../stubs/mushi.composition.power.html#mushi.composition.power">[docs]</a><span class="k">def</span> <span class="nf">power</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs the power operation.</span>

<span class="sd">    This operation is defined as follows</span>

<span class="sd">    .. math::</span>
<span class="sd">        `x \odot a = C[x_1^a, \ldots, x_D^a]</span>

<span class="sd">    :math:`C[x]` is the closure operation defined as</span>

<span class="sd">    .. math::</span>
<span class="sd">        C[x] = \left[\frac{x_1}{\sum_{i=1}^{D} x_i},\ldots,</span>
<span class="sd">                     \frac{x_D}{\sum_{i=1}^{D} x_i} \right]</span>

<span class="sd">    for some :math:`D` dimensional real vector :math:`x` and</span>
<span class="sd">    :math:`D` is the number of components for every composition.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like, float</span>
<span class="sd">        a matrix of proportions where</span>
<span class="sd">        rows = compositions and</span>
<span class="sd">        columns = components</span>
<span class="sd">    a : float</span>
<span class="sd">        a scalar float</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray, np.float64</span>
<span class="sd">       A matrix of proportions where all of the values</span>
<span class="sd">       are nonzero and each composition (row) adds up to 1</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import mushi.composition as cmp</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([.1,.3,.4, .2])</span>
<span class="sd">    &gt;&gt;&gt; cmp.power(x, .1)</span>
<span class="sd">    DeviceArray([0.23059566, 0.25737316, 0.26488486, 0.24714631], dtype=float64)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">closure</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">closure</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span></div>


<div class="viewcode-block" id="inner"><a class="viewcode-back" href="../../stubs/mushi.composition.inner.html#mushi.composition.inner">[docs]</a><span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the Aitchson inner product.</span>

<span class="sd">    This inner product is defined as follows</span>

<span class="sd">    .. math::</span>
<span class="sd">        \langle x, y \rangle_a =</span>
<span class="sd">        \frac{1}{2D} \sum\limits_{i=1}^{D} \sum\limits_{j=1}^{D}</span>
<span class="sd">        \ln\left(\frac{x_i}{x_j}\right) \ln\left(\frac{y_i}{y_j}\right)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        a matrix of proportions where</span>
<span class="sd">        rows = compositions and</span>
<span class="sd">        columns = components</span>
<span class="sd">    y : array_like</span>
<span class="sd">        a matrix of proportions where</span>
<span class="sd">        rows = compositions and</span>
<span class="sd">        columns = components</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">         inner product result</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import mushi.composition as cmp</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([.1, .3, .4, .2])</span>
<span class="sd">    &gt;&gt;&gt; y = np.array([.2, .4, .2, .2])</span>
<span class="sd">    &gt;&gt;&gt; cmp.inner(x, y)  # doctest: +ELLIPSIS</span>
<span class="sd">    DeviceArray(0.21078525, dtype=float64)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">closure</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">closure</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">clr</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">clr</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">T</span><span class="p">)</span></div>


<div class="viewcode-block" id="clr"><a class="viewcode-back" href="../../stubs/mushi.composition.clr.html#mushi.composition.clr">[docs]</a><span class="k">def</span> <span class="nf">clr</span><span class="p">(</span><span class="n">mat</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs centre log ratio transformation.</span>

<span class="sd">    This function transforms compositions from Aitchison geometry to</span>
<span class="sd">    the real space. The :math:`clr` transform is both an isometry and an</span>
<span class="sd">    isomorphism defined on the following spaces</span>

<span class="sd">    :math:`clr: S^D \rightarrow U`</span>

<span class="sd">    where :math:`U=</span>
<span class="sd">    \{x :\sum\limits_{i=1}^D x = 0 \; \forall x \in \mathbb{R}^D\}`</span>

<span class="sd">    It is defined for a composition :math:`x` as follows:</span>

<span class="sd">    .. math::</span>
<span class="sd">        clr(x) = \ln\left[\frac{x_1}{g_m(x)}, \ldots, \frac{x_D}{g_m(x)}\right]</span>

<span class="sd">    where :math:`g_m(x) = (\prod\limits_{i=1}^{D} x_i)^{1/D}` is the geometric</span>
<span class="sd">    mean of :math:`x`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mat : array_like, float</span>
<span class="sd">       a matrix of proportions where</span>
<span class="sd">       rows = compositions and</span>
<span class="sd">       columns = components</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">         clr transformed matrix</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import mushi.composition as cmp</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([.1, .3, .4, .2])</span>
<span class="sd">    &gt;&gt;&gt; cmp.clr(x)</span>
<span class="sd">    DeviceArray([-0.79451346,  0.30409883,  0.5917809 , -0.10136628], dtype=float64)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="n">closure</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
    <span class="n">lmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
    <span class="n">gm</span> <span class="o">=</span> <span class="n">lmat</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">lmat</span> <span class="o">-</span> <span class="n">gm</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span></div>


<div class="viewcode-block" id="clr_inv"><a class="viewcode-back" href="../../stubs/mushi.composition.clr_inv.html#mushi.composition.clr_inv">[docs]</a><span class="k">def</span> <span class="nf">clr_inv</span><span class="p">(</span><span class="n">mat</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs inverse centre log ratio transformation.</span>

<span class="sd">    This function transforms compositions from the real space to</span>
<span class="sd">    Aitchison geometry. The :math:`clr^{-1}` transform is both an isometry,</span>
<span class="sd">    and an isomorphism defined on the following spaces</span>

<span class="sd">    :math:`clr^{-1}: U \rightarrow S^D`</span>

<span class="sd">    where :math:`U=</span>
<span class="sd">    \{x :\sum\limits_{i=1}^D x = 0 \; \forall x \in \mathbb{R}^D\}`</span>

<span class="sd">    This transformation is defined as follows</span>

<span class="sd">    .. math::</span>
<span class="sd">        clr^{-1}(x) = C[\exp( x_1, \ldots, x_D)]</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mat : array_like, float</span>
<span class="sd">       a matrix of real values where</span>
<span class="sd">       rows = transformed compositions and</span>
<span class="sd">       columns = components</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">         inverse clr transformed matrix</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import mushi.composition as cmp</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([.1, .3, .4, .2])</span>
<span class="sd">    &gt;&gt;&gt; cmp.clr_inv(x)</span>
<span class="sd">    DeviceArray([0.21383822, 0.26118259, 0.28865141, 0.23632778], dtype=float64)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">closure</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mat</span><span class="p">))</span></div>


<div class="viewcode-block" id="ilr"><a class="viewcode-back" href="../../stubs/mushi.composition.ilr.html#mushi.composition.ilr">[docs]</a><span class="k">def</span> <span class="nf">ilr</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs isometric log ratio transformation.</span>

<span class="sd">    This function transforms compositions from Aitchison simplex to</span>
<span class="sd">    the real space. The :math: ilr` transform is both an isometry,</span>
<span class="sd">    and an isomorphism defined on the following spaces</span>

<span class="sd">    :math:`ilr: S^D \rightarrow \mathbb{R}^{D-1}`</span>

<span class="sd">    The ilr transformation is defined as follows</span>

<span class="sd">    .. math::</span>
<span class="sd">        ilr(x) =</span>
<span class="sd">        [\langle x, e_1 \rangle_a, \ldots, \langle x, e_{D-1} \rangle_a]</span>

<span class="sd">    where :math:`[e_1,\ldots,e_{D-1}]` is an orthonormal basis in the simplex.</span>

<span class="sd">    If an orthornormal basis isn&#39;t specified, the J. J. Egozcue orthonormal</span>
<span class="sd">    basis derived from Gram-Schmidt orthogonalization will be used by</span>
<span class="sd">    default.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mat: numpy.ndarray</span>
<span class="sd">       a matrix of proportions where</span>
<span class="sd">       rows = compositions and</span>
<span class="sd">       columns = components</span>

<span class="sd">    basis: numpy.ndarray, float, optional</span>
<span class="sd">        orthonormal basis for Aitchison simplex</span>
<span class="sd">        defaults to J.J.Egozcue orthonormal basis</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import mushi.composition as cmp</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([.1, .3, .4, .2])</span>
<span class="sd">    &gt;&gt;&gt; cmp.ilr(x)</span>
<span class="sd">    DeviceArray([-0.7768362 , -0.68339802,  0.11704769], dtype=float64)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="n">closure</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">basis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">basis</span> <span class="o">=</span> <span class="n">_gram_schmidt_basis</span><span class="p">(</span><span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">check</span><span class="p">:</span>
        <span class="n">_check_orthogonality</span><span class="p">(</span><span class="n">clr_inv</span><span class="p">(</span><span class="n">basis</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">inner</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">clr_inv</span><span class="p">(</span><span class="n">basis</span><span class="p">))</span></div>


<div class="viewcode-block" id="ilr_inv"><a class="viewcode-back" href="../../stubs/mushi.composition.ilr_inv.html#mushi.composition.ilr_inv">[docs]</a><span class="k">def</span> <span class="nf">ilr_inv</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">basis</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs inverse isometric log ratio transform.</span>

<span class="sd">    This function transforms compositions from the real space to</span>
<span class="sd">    Aitchison geometry. The :math:`ilr^{-1}` transform is both an isometry,</span>
<span class="sd">    and an isomorphism defined on the following spaces</span>

<span class="sd">    :math:`ilr^{-1}: \mathbb{R}^{D-1} \rightarrow S^D`</span>

<span class="sd">    The inverse ilr transformation is defined as follows</span>

<span class="sd">    .. math::</span>
<span class="sd">        ilr^{-1}(x) = \bigoplus\limits_{i=1}^{D-1} x \odot e_i</span>

<span class="sd">    where :math:`[e_1,\ldots, e_{D-1}]` is an orthonormal basis in the simplex.</span>

<span class="sd">    If an orthornormal basis isn&#39;t specified, the J. J. Egozcue orthonormal</span>
<span class="sd">    basis derived from Gram-Schmidt orthogonalization will be used by</span>
<span class="sd">    default.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mat: numpy.ndarray, float</span>
<span class="sd">       a matrix of transformed proportions where</span>
<span class="sd">       rows = compositions and</span>
<span class="sd">       columns = components</span>

<span class="sd">    basis: numpy.ndarray, float, optional</span>
<span class="sd">        orthonormal basis for Aitchison simplex</span>
<span class="sd">        defaults to J.J.Egozcue orthonormal basis</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import mushi.composition as cmp</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([.1, .3, .6,])</span>
<span class="sd">    &gt;&gt;&gt; basis = cmp._gram_schmidt_basis(4)</span>
<span class="sd">    &gt;&gt;&gt; cmp.ilr_inv(x, basis)</span>
<span class="sd">    DeviceArray([0.34180297, 0.29672718, 0.22054469, 0.14092516], dtype=float64)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">clr_inv</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">basis</span><span class="p">))</span></div>


<div class="viewcode-block" id="centralize"><a class="viewcode-back" href="../../stubs/mushi.composition.centralize.html#mushi.composition.centralize">[docs]</a><span class="k">def</span> <span class="nf">centralize</span><span class="p">(</span><span class="n">mat</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Center data around its geometric average.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mat : array_like, float</span>
<span class="sd">       a matrix of proportions where</span>
<span class="sd">       rows = compositions and</span>
<span class="sd">       columns = components</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">         centered composition matrix</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import mushi.composition as cmp</span>
<span class="sd">    &gt;&gt;&gt; X = np.array([[.1,.3,.4, .2],[.2,.2,.2,.4]])</span>
<span class="sd">    &gt;&gt;&gt; cmp.centralize(X)</span>
<span class="sd">    DeviceArray([[0.17445763, 0.30216948, 0.34891526, 0.17445763],</span>
<span class="sd">                 [0.32495488, 0.18761279, 0.16247744, 0.32495488]],            dtype=float64)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="n">closure</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
    <span class="n">cen</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">gmean</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">perturb_inv</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">cen</span><span class="p">)</span></div>


<div class="viewcode-block" id="ancom"><a class="viewcode-back" href="../../stubs/mushi.composition.ancom.html#mushi.composition.ancom">[docs]</a><span class="k">def</span> <span class="nf">ancom</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">grouping</span><span class="p">,</span>
          <span class="n">alpha</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>
          <span class="n">tau</span><span class="o">=</span><span class="mf">0.02</span><span class="p">,</span>
          <span class="n">theta</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
          <span class="n">multiple_comparisons_correction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
          <span class="n">significance_test</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Performs a differential abundance test using ANCOM.</span>

<span class="sd">    This is done by calculating pairwise log ratios between all features</span>
<span class="sd">    and performing a significance test to determine if there is a significant</span>
<span class="sd">    difference in feature ratios with respect to the variable of interest.</span>

<span class="sd">    In an experiment with only two treatments, this test tests the following</span>
<span class="sd">    hypothesis for feature :math:`i`</span>

<span class="sd">    .. math::</span>

<span class="sd">        H_{0i}: \mathbb{E}[\ln(u_i^{(1)})] = \mathbb{E}[\ln(u_i^{(2)})]</span>

<span class="sd">    where :math:`u_i^{(1)}` is the mean abundance for feature :math:`i` in the</span>
<span class="sd">    first group and :math:`u_i^{(2)}` is the mean abundance for feature</span>
<span class="sd">    :math:`i` in the second group.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    table : pd.DataFrame</span>
<span class="sd">        A 2D matrix of strictly positive values (i.e. counts or proportions)</span>
<span class="sd">        where the rows correspond to samples and the columns correspond to</span>
<span class="sd">        features.</span>
<span class="sd">    grouping : pd.Series</span>
<span class="sd">        Vector indicating the assignment of samples to groups.  For example,</span>
<span class="sd">        these could be strings or integers denoting which group a sample</span>
<span class="sd">        belongs to.  It must be the same length as the samples in `table`.</span>
<span class="sd">        The index must be the same on `table` and `grouping` but need not be</span>
<span class="sd">        in the same order.</span>
<span class="sd">    alpha : float, optional</span>
<span class="sd">        Significance level for each of the statistical tests.</span>
<span class="sd">        This can can be anywhere between 0 and 1 exclusive.</span>
<span class="sd">    tau : float, optional</span>
<span class="sd">        A constant used to determine an appropriate cutoff.</span>
<span class="sd">        A value close to zero indicates a conservative cutoff.</span>
<span class="sd">        This can can be anywhere between 0 and 1 exclusive.</span>
<span class="sd">    theta : float, optional</span>
<span class="sd">        Lower bound for the proportion for the W-statistic.</span>
<span class="sd">        If all W-statistics are lower than theta, then no features</span>
<span class="sd">        will be detected to be differentially significant.</span>
<span class="sd">        This can can be anywhere between 0 and 1 exclusive.</span>
<span class="sd">    multiple_comparisons_correction : {None, &#39;holm-bonferroni&#39;}, optional</span>
<span class="sd">        The multiple comparison correction procedure to run.  If None,</span>
<span class="sd">        then no multiple comparison correction procedure will be run.</span>
<span class="sd">        If &#39;holm-boniferroni&#39; is specified, then the Holm-Boniferroni</span>
<span class="sd">        procedure [1]_ will be run.</span>
<span class="sd">    significance_test : function, optional</span>
<span class="sd">        A statistical significance function to test for significance between</span>
<span class="sd">        classes.  This function must be able to accept at least two 1D</span>
<span class="sd">        array_like arguments of floats and returns a test statistic and a</span>
<span class="sd">        p-value. By default ``scipy.stats.f_oneway`` is used.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pd.DataFrame</span>
<span class="sd">        A table of features, their W-statistics and whether the null hypothesis</span>
<span class="sd">        is rejected.</span>

<span class="sd">        `&quot;W&quot;` is the W-statistic, or number of features that a single feature</span>
<span class="sd">        is tested to be significantly different against.</span>

<span class="sd">        `&quot;reject&quot;` indicates if feature is significantly different or not.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    multiplicative_replacement</span>
<span class="sd">    scipy.stats.ttest_ind</span>
<span class="sd">    scipy.stats.f_oneway</span>
<span class="sd">    scipy.stats.wilcoxon</span>
<span class="sd">    scipy.stats.kruskal</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The developers of this method recommend the following significance tests</span>
<span class="sd">    ([2]_, Supplementary File 1, top of page 11): the standard parametric</span>
<span class="sd">    t-test (``scipy.stats.ttest_ind``) or one-way ANOVA</span>
<span class="sd">    (``scipy.stats.f_oneway``) if the number of groups is greater</span>
<span class="sd">    than 2, or non-parametric variants such as Wilcoxon rank sum</span>
<span class="sd">    (``scipy.stats.wilcoxon``) or Kruskal-Wallis (``scipy.stats.kruskal``)</span>
<span class="sd">    if the number of groups is greater than 2.  Because one-way ANOVA is</span>
<span class="sd">    equivalent to the standard t-test when the number of groups is two,</span>
<span class="sd">    we default to ``scipy.stats.f_oneway`` here, which can be used when</span>
<span class="sd">    there are two or more groups.  Users should refer to the documentation</span>
<span class="sd">    of these tests in SciPy to understand the assumptions made by each test.</span>

<span class="sd">    This method cannot handle any zero counts as input, since the logarithm</span>
<span class="sd">    of zero cannot be computed.  While this is an unsolved problem, many</span>
<span class="sd">    studies have shown promising results by replacing the zeros with pseudo</span>
<span class="sd">    counts. This can be also be done via the ``multiplicative_replacement``</span>
<span class="sd">    method.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Holm, S. &quot;A simple sequentially rejective multiple test procedure&quot;.</span>
<span class="sd">       Scandinavian Journal of Statistics (1979), 6.</span>
<span class="sd">    .. [2] Mandal et al. &quot;Analysis of composition of microbiomes: a novel</span>
<span class="sd">       method for studying microbial composition&quot;, Microbial Ecology in Health</span>
<span class="sd">       &amp; Disease, (2015), 26.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    First import all of the necessary modules:</span>

<span class="sd">    &gt;&gt;&gt; import mushi.composition as cmp</span>
<span class="sd">    &gt;&gt;&gt; import pandas as pd</span>

<span class="sd">    Now let&#39;s load in a pd.DataFrame with 6 samples and 7 unknown bacteria:</span>

<span class="sd">    &gt;&gt;&gt; table = pd.DataFrame([[12, 11, 10, 10, 10, 10, 10],</span>
<span class="sd">    ...                       [9,  11, 12, 10, 10, 10, 10],</span>
<span class="sd">    ...                       [1,  11, 10, 11, 10, 5,  9],</span>
<span class="sd">    ...                       [22, 21, 9,  10, 10, 10, 10],</span>
<span class="sd">    ...                       [20, 22, 10, 10, 13, 10, 10],</span>
<span class="sd">    ...                       [23, 21, 14, 10, 10, 10, 10]],</span>
<span class="sd">    ...                      index=[&#39;s1&#39;,&#39;s2&#39;,&#39;s3&#39;,&#39;s4&#39;,&#39;s5&#39;,&#39;s6&#39;],</span>
<span class="sd">    ...                      columns=[&#39;b1&#39;,&#39;b2&#39;,&#39;b3&#39;,&#39;b4&#39;,&#39;b5&#39;,&#39;b6&#39;,&#39;b7&#39;])</span>

<span class="sd">    Then create a grouping vector.  In this scenario, there</span>
<span class="sd">    are only two classes, and suppose these classes correspond to the</span>
<span class="sd">    treatment due to a drug and a control.  The first three samples</span>
<span class="sd">    are controls and the last three samples are treatments.</span>

<span class="sd">    &gt;&gt;&gt; grouping = pd.Series([0, 0, 0, 1, 1, 1],</span>
<span class="sd">    ...                      index=[&#39;s1&#39;,&#39;s2&#39;,&#39;s3&#39;,&#39;s4&#39;,&#39;s5&#39;,&#39;s6&#39;])</span>

<span class="sd">    Now run ``ancom`` and see if there are any features that have any</span>
<span class="sd">    significant differences between the treatment and the control.</span>

<span class="sd">    &gt;&gt;&gt; results = cmp.ancom(table, grouping) # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; results[&#39;W&#39;] # doctest: +SKIP</span>
<span class="sd">    b1    0</span>
<span class="sd">    b2    4</span>
<span class="sd">    b3    1</span>
<span class="sd">    b4    1</span>
<span class="sd">    b5    1</span>
<span class="sd">    b6    0</span>
<span class="sd">    b7    1</span>
<span class="sd">    Name: W, dtype: np.int64</span>

<span class="sd">    The W-statistic is the number of features that a single feature is tested</span>
<span class="sd">    to be significantly different against.  In this scenario, `b2` was detected</span>
<span class="sd">    to have significantly different abundances compared to four of the other</span>
<span class="sd">    species. To summarize the results from the W-statistic, let&#39;s take a look</span>
<span class="sd">    at the results from the hypothesis test:</span>

<span class="sd">    &gt;&gt;&gt; results[&#39;reject&#39;] # doctest: +SKIP</span>
<span class="sd">    b1    False</span>
<span class="sd">    b2     True</span>
<span class="sd">    b3    False</span>
<span class="sd">    b4    False</span>
<span class="sd">    b5    False</span>
<span class="sd">    b6    False</span>
<span class="sd">    b7    False</span>
<span class="sd">    Name: reject, dtype: bool</span>

<span class="sd">    From this we can conclude that only `b2` was significantly</span>
<span class="sd">    different between the treatment and the control.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`table` must be a `pd.DataFrame`, &#39;</span>
                        <span class="s1">&#39;not </span><span class="si">%r</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">table</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grouping</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`grouping` must be a `pd.Series`,&#39;</span>
                        <span class="s1">&#39; not </span><span class="si">%r</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">grouping</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">table</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot handle zeros or negative values in `table`. &#39;</span>
                         <span class="s1">&#39;Use pseudo counts or ``multiplicative_replacement``.&#39;</span>
                         <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">alpha</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`alpha`=</span><span class="si">%f</span><span class="s1"> is not within 0 and 1.&#39;</span> <span class="o">%</span> <span class="n">alpha</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">tau</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`tau`=</span><span class="si">%f</span><span class="s1"> is not within 0 and 1.&#39;</span> <span class="o">%</span> <span class="n">tau</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">theta</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`theta`=</span><span class="si">%f</span><span class="s1"> is not within 0 and 1.&#39;</span> <span class="o">%</span> <span class="n">theta</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">multiple_comparisons_correction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">multiple_comparisons_correction</span> <span class="o">!=</span> <span class="s1">&#39;holm-bonferroni&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%r</span><span class="s1"> is not an available option for &#39;</span>
                             <span class="s1">&#39;`multiple_comparisons_correction`.&#39;</span>
                             <span class="o">%</span> <span class="n">multiple_comparisons_correction</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">grouping</span><span class="o">.</span><span class="n">isnull</span><span class="p">())</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot handle missing values in `grouping`.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">isnull</span><span class="p">())</span><span class="o">.</span><span class="n">any</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot handle missing values in `table`.&#39;</span><span class="p">)</span>

    <span class="n">groups</span><span class="p">,</span> <span class="n">_grouping</span> <span class="o">=</span> <span class="n">onp</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">grouping</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">grouping</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">_grouping</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">grouping</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
    <span class="n">num_groups</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">num_groups</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">grouping</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;All values in `grouping` are unique. This method cannot &quot;</span>
            <span class="s2">&quot;operate on a grouping vector with only unique values (e.g., &quot;</span>
            <span class="s2">&quot;there are no &#39;within&#39; variance because each group of samples &quot;</span>
            <span class="s2">&quot;contains only a single sample).&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">num_groups</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;All values the `grouping` are the same. This method cannot &quot;</span>
            <span class="s2">&quot;operate on a grouping vector with only a single group of samples&quot;</span>
            <span class="s2">&quot;(e.g., there are no &#39;between&#39; variance because there is only a &quot;</span>
            <span class="s2">&quot;single group).&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">significance_test</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">significance_test</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">f_oneway</span>

    <span class="n">table_index_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
    <span class="n">grouping_index_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grouping</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
    <span class="n">mat</span><span class="p">,</span> <span class="n">cats</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">grouping</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s1">&#39;inner&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span> <span class="o">!=</span> <span class="n">table_index_len</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">cats</span><span class="p">)</span> <span class="o">!=</span> <span class="n">grouping_index_len</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`table` index and `grouping` &#39;</span>
                         <span class="s1">&#39;index must be consistent.&#39;</span><span class="p">)</span>

    <span class="n">n_feat</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">_logratio_mat</span> <span class="o">=</span> <span class="n">_log_compare</span><span class="p">(</span><span class="n">mat</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">cats</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">significance_test</span><span class="p">)</span>
    <span class="n">logratio_mat</span> <span class="o">=</span> <span class="n">_logratio_mat</span> <span class="o">+</span> <span class="n">_logratio_mat</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># Multiple comparisons</span>
    <span class="k">if</span> <span class="n">multiple_comparisons_correction</span> <span class="o">==</span> <span class="s1">&#39;holm-bonferroni&#39;</span><span class="p">:</span>
        <span class="n">logratio_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">_holm_bonferroni</span><span class="p">,</span>
                                           <span class="mi">1</span><span class="p">,</span> <span class="n">logratio_mat</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">logratio_mat</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">W</span> <span class="o">=</span> <span class="p">(</span><span class="n">logratio_mat</span> <span class="o">&lt;</span> <span class="n">alpha</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">c_start</span> <span class="o">=</span> <span class="n">W</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">/</span> <span class="n">n_feat</span>
    <span class="k">if</span> <span class="n">c_start</span> <span class="o">&lt;</span> <span class="n">theta</span><span class="p">:</span>
        <span class="n">reject</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Select appropriate cutoff</span>
        <span class="n">cutoff</span> <span class="o">=</span> <span class="n">c_start</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
        <span class="n">prop_cut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">W</span> <span class="o">&gt;</span> <span class="n">n_feat</span><span class="o">*</span><span class="n">cut</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="k">for</span> <span class="n">cut</span> <span class="ow">in</span> <span class="n">cutoff</span><span class="p">])</span>
        <span class="n">dels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">prop_cut</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">prop_cut</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">dels</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">dels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tau</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">dels</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tau</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">dels</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tau</span><span class="p">):</span>
            <span class="n">nu</span> <span class="o">=</span> <span class="n">cutoff</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">dels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">tau</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">dels</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tau</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">dels</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tau</span><span class="p">):</span>
            <span class="n">nu</span> <span class="o">=</span> <span class="n">cutoff</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">dels</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">tau</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">dels</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tau</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">dels</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tau</span><span class="p">):</span>
            <span class="n">nu</span> <span class="o">=</span> <span class="n">cutoff</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nu</span> <span class="o">=</span> <span class="n">cutoff</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">reject</span> <span class="o">=</span> <span class="p">(</span><span class="n">W</span> <span class="o">&gt;=</span> <span class="n">nu</span><span class="o">*</span><span class="n">n_feat</span><span class="p">)</span>
    <span class="n">labs</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">columns</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;W&#39;</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">labs</span><span class="p">),</span>
                         <span class="s1">&#39;reject&#39;</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">reject</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">labs</span><span class="p">)})</span></div>


<span class="k">def</span> <span class="nf">_holm_bonferroni</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Performs Holm-Bonferroni correction for pvalues</span>
<span class="sd">    to account for multiple comparisons</span>

<span class="sd">    Parameters</span>
<span class="sd">    ---------</span>
<span class="sd">    p: numpy.array</span>
<span class="sd">        array of pvalues</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.array</span>
<span class="sd">        corrected pvalues</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">K</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">sort_index</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">sorted_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">sorted_p_adj</span> <span class="o">=</span> <span class="n">sorted_p</span><span class="o">*</span><span class="p">(</span><span class="n">K</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">K</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">sorted_p</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">sort_index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">num_ties</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sort_index</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
        <span class="n">sort_index</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="n">num_ties</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

    <span class="n">sorted_holm_p</span> <span class="o">=</span> <span class="p">[</span><span class="nb">min</span><span class="p">([</span><span class="nb">max</span><span class="p">(</span><span class="n">sorted_p_adj</span><span class="p">[:</span><span class="n">k</span><span class="p">]),</span> <span class="mi">1</span><span class="p">])</span>
                     <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">K</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">holm_p</span> <span class="o">=</span> <span class="p">[</span><span class="n">sorted_holm_p</span><span class="p">[</span><span class="n">sort_index</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">holm_p</span>


<span class="k">def</span> <span class="nf">_log_compare</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">cats</span><span class="p">,</span>
                 <span class="n">significance_test</span><span class="o">=</span><span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">ttest_ind</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculates pairwise log ratios between all features and performs a</span>
<span class="sd">    significiance test (i.e. t-test) to determine if there is a significant</span>
<span class="sd">    difference in feature ratios with respect to the variable of interest.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mat: np.array</span>
<span class="sd">       rows correspond to samples and columns correspond to</span>
<span class="sd">       features (i.e. OTUs)</span>
<span class="sd">    cats: np.array, float</span>
<span class="sd">       Vector of categories</span>
<span class="sd">    significance_test: function</span>
<span class="sd">        statistical test to run</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    log_ratio : np.array</span>
<span class="sd">        log ratio pvalue matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">log_ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>
    <span class="n">log_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
    <span class="n">cs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cats</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">significance_test</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="n">cats</span> <span class="o">==</span> <span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cs</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">c</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">ratio</span> <span class="o">=</span> <span class="p">(</span><span class="n">log_mat</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">log_mat</span><span class="p">[:,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">func</span><span class="p">,</span>
                                   <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                   <span class="n">arr</span><span class="o">=</span><span class="n">ratio</span><span class="p">)</span>
        <span class="n">log_ratio</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">log_ratio</span>


<span class="k">def</span> <span class="nf">_gram_schmidt_basis</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Builds clr transformed basis derived from</span>
<span class="sd">    gram schmidt orthogonalization</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Dimension of the Aitchison simplex</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">basis</span> <span class="o">=</span> <span class="n">onp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">onp</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mi">1</span><span class="o">/</span><span class="n">i</span><span class="p">)]</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
                     <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">i</span><span class="o">/</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">basis</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span>
    <span class="k">return</span> <span class="n">basis</span><span class="o">.</span><span class="n">T</span>


<span class="k">def</span> <span class="nf">_check_orthogonality</span><span class="p">(</span><span class="n">basis</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks to see if basis is truly orthonormal in the</span>
<span class="sd">    Aitchison simplex</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    basis: numpy.ndarray</span>
<span class="sd">        basis in the Aitchison simplex</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">inner</span><span class="p">(</span><span class="n">basis</span><span class="p">,</span> <span class="n">basis</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">basis</span><span class="p">)),</span>
                       <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Aitchison basis is not orthonormal&quot;</span><span class="p">)</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, William DeWitt, Kameron Decker Harris, and Kelley Harris

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>